{"pages":[{"title":"firstpage","text":"","link":"/firstpage/index.html"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/firstpage/hello-world.html"}],"posts":[{"title":"first-blog","text":"","link":"/2021/02/11/first-blog/"},{"title":"leetcode-132-简谈分割回文串","text":"f[i,j]表示s[i……j](闭区间)是不是回文串，显然这是一个可以预处理的数组。 我的思路是枚举回文串的中心，这样能做到很自然地递推。 结果就这么简单的东西还是疏忽了一点：回文串的中心分奇数长度和偶数长度两种情况。大晕厥，不过还好样例是偶数中心的情况。 12345678910111213141516171819202122for(int i=0; i&lt;n; i++){ // j means step rev[i][i] = true; for(int j=1; j&lt;n; j++){ if(i-j&lt;0 || i+j&gt;=n){ break; } if(s[i-j]==s[i+j]) rev[i-j][i+j] = true; else break; } for(int j=1; j&lt;n; j++){ if(i-j+1&lt;0 || i+j&gt;=n){ break; } if(s[i-j+1]==s[i+j]) rev[i-j+1][i+j] = true; else break; } } 官方的做法是： 123456f.assign(n, vector&lt;bool&gt;(n,true)); for(int i=n-1; i&gt;=0; i--){ for(int j=i+1; j&lt;n; j++){ f[i][j] = (s[i]==s[j]) &amp;&amp; f[i+1][j-1]; } } 一开始还有点困惑，因为我总是对dp的递推顺序无法有个很清晰的理解。但自己尝试过后就懂了。其中i的方向是从n到0，j从0到n。 为什么呢，因为f[i][j]是从f[i+1][j-1]递推而来，事实上这个+1和-1中暗含了dp的方向。这其实挺巧妙的 132其实是分割回文串II，是一道典型的dp。乍一看找方案数似乎顺着I的思路深搜，复杂度就爆炸了。瞄了眼题解看到dp定义是一维的就秒懂了。 似乎之前做过很多类似的题目，其转移方程均为 ​ dp[i] = min( dp[j] + 1) if f[j+1][i] == 1 , 0&lt;=j&lt;i. 如果知道了答案会觉得很理所当然，但是碰到这种题目往往会陷入一种误区，为什么dp的定义不是dp[i][j]表示i到j的最小分割数，而是dp[i]表示0到i的最小分割数呢？ 我理解是，如果采用dp[i][j]来定义，其实是把问题复杂化，或者说没有最大程度地简化问题。如果设定是二维的，一种很直觉上很正确的递推方程是： ​ dp[i][j] = min(dp[i][k] + dp[k+1][j]) , 0&lt;=k&lt;=i 然而事实上这个方程等价于一维的递推方程，假设有一个最优分割，分割点在x1,x2…,xn处，那二维情况的最优解会在每个分割点处都得到，而一维的会在xn处得到，因此两者得到的都是最优解。 ​ 从这个角度来说，用一维的原因是，能用一维，既然能用一维干嘛要用二维呢？","link":"/2021/03/10/leetcode-132-%E7%AE%80%E8%B0%88%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"},{"title":"LeetCode周赛-235","text":"这周起晚了半小时，前三题非常水，第四题看了眼感觉是枚举，但是思路比较乱，遂放弃 Problem A - 截断句子散讲：看到第一题，啪的一下就切换到python3 123class Solution: def truncateSentence(self, s: str, k: int) -&gt; str: return &quot; &quot;.join(s.split(' ')[0:k]) Problem B - 查找用户活跃分钟数散讲：看题面看了10分钟没懂“用户活跃分钟数”的定义，已经很久没出现这种秀逗的状况了。做完第三题再看就秒懂了。应该是题面本身也有一定的歧义，看题解也有人看一小时没看懂的。 解：map里装&lt;id,set()&gt;就行了，自己写的c++比较繁琐，贴个python的。比赛时想写python，但用不熟set。 如果s = {1,2,}，这样s是一个set；如果s={1:1,2:2}，这样s是一个dict 123456789101112131415class Solution: def findingUsersActiveMinutes(self, logs, k): ret = [0 for _ in range(k)] d = {} for i in logs: id, time = i if id not in d: d[id] = {time, } else: d[id].add(time) for j in d.values(): count = len(j) if count &lt;= k: ret[count - 1] += 1 return ret Problem C - 绝对差值和思路很明显，枚举nums2中的每一个数，在nums1里二分找最接近的两个数，最后结果是替换后贡献最大的。 手撸过很多次二分后终于感觉有点熟练各种二分的变形了，什么时候有机会可以写一写。这里再次学习一下stl里的二分： ForwardIter lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。 ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)算法返回一个非递减序列[first, last)中第一个大于val的位置。 这里的上界和下界和数分里学的有些许出入。贴张图很容易看明白这两个函数的作用： 随手贴个本题代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: int minAbsoluteSumDiff(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int n = nums1.size(); int mod[n]; for(int i=0; i&lt;n; i++){ mod[i] = abs(nums1[i] - nums2[i]); } vector sortnum = nums1; int besgap = 0; sort(sortnum.begin(), sortnum.end()); for(int i=0; i&lt;n; i++){ int bes = best(sortnum, nums2[i]); besgap = max(besgap, mod[i] - bes); } const int MOD = 1e9 + 7; int ret = -besgap; for(int i=0; i&lt;n; i++){ ret = (ret + mod[i]) % MOD; } return ret; } int best(vector&lt;int&gt;&amp; sortnum, int x){ int n = sortnum.size(); int l = 0, r = n-1; int ret = 99999999; while(l&lt;r){ int mid = (l + (r-l+1)/2); if(sortnum[mid] &gt; x){ r = mid -1; } else{ l = mid; } } ret = abs(x - sortnum[l]); l = 0; r = n-1; while(l&lt;r){ int mid = (l + (r-l)/2); if(sortnum[mid] &gt;= x){ r = mid; } else{ l = mid + 1; } } ret = min(ret, abs(x-sortnum[r])); return ret; }}; Problem D - 序列中不同最大公约数的数目拿到题面，有两条思路可走： 有技巧地枚举子集。直接枚举子集显然时间复杂度太高，为了降低复杂度：要么找规律剪掉大部分的枝；要么通过dp等记忆化方式。 枚举答案，看某个数能不能成为答案。 第一条路没有什么明显的思路，比赛的时候试图用dp但是没设计出什么。 于是考虑第二条思路：“判断某个数x能不能成为子序列的最大公因数” -&gt; “找出数组中与该数相关的数，即因子包含x的数，即t*x” -&gt; “判断 [t1*x, t2*x, …. tn*x]是否存在一个子集，该子集的最大公因数为x” 然后就是关键的一步，注意到x是小于等于 [t1*x, t2*x, …. tn*x] 中任意一个数的，这说明如果存在一个子集最大公因数为x，说明 [t1*x, t2*x, …. tn*x]的最大公因数也为x，而gcd( [t1*x, t2*x, …. tn*x])可以通过递推的方式求，从代码中也可以看出tmp作为当前的最大公因数，它只会减不会增。 举个例子，判断x=3有没有可能是[6,12,9]的最大公因数，首先tmp=6，然后tmp=gcd(6,12)=6，最后tmp=gcd(6,9)=3。到这里可以看出问题可以进一步转变为：是否存在子集，他们的公因子只有x和1，没有其他数了。不过这本来也是最大公因数的定义。 最后算时间复杂度：感觉题解算的不对，应该是O(m*log(m)*log(m))，第一个log是调和级数，第二个是gcd的均摊复杂度 1234567891011121314151617181920212223242526272829303132class Solution {public: int gcd(int a, int b){ if(a%b==0) return b; return gcd(b, a%b); } int countDifferentSubsequenceGCDs(vector&lt;int&gt;&amp; nums) { const int MAXN = 200000; bool vis[MAXN+1]; int ret = 0; memset(vis, 0, sizeof(bool)*(MAXN+1)); for(auto num:nums) vis[num] = true; for(int i=1; i&lt;=MAXN; i++){ int tmp = -1; for(int j=i; j&lt;=MAXN; j+=i){ if(vis[j]){ if(tmp==-1) tmp = j; else tmp = gcd(tmp, j); } } if(tmp == i) ret++; } return ret; }}; 完。","link":"/2021/04/05/LeetCode%E5%91%A8%E8%B5%9B-235/"},{"title":"Leetcode春季战队赛","text":"Problem A - 截断句子散讲：看到第一题，啪的一下就切换到python3 123class Solution: def truncateSentence(self, s: str, k: int) -&gt; str: return &quot; &quot;.join(s.split(' ')[0:k]) 站个坑， 这周一定写完题目和题解 —— 4.15 Problem B - 查找用户活跃分钟数散讲：看题面看了10分钟没懂“用户活跃分钟数”的定义，已经很久没出现这种秀逗的状况了。做完第三题再看就秒懂了。应该是题面本身也有一定的歧义，看题解也有人看一小时没看懂的。 解：map里装&lt;id,set()&gt;就行了，自己写的c++比较繁琐，贴个python的。比赛时想写python，但用不熟set。","link":"/2021/04/15/Leetcode%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/"},{"title":"CMU15-445数据库系统课程学习笔记","text":"最近想找一个c++项目写在简历上，思前想后还是觉得CMU的课程项目做起来比较顺手，于是选了15-445的数据库课程。 资料链接： 课程主页：https://15445.courses.cs.cmu.edu/fall2018/index.html 某CSDN作者的lab代码：https://github.com/liu-jianhao/CMU-15-445 教材：《数据库系统概念》 第一周：视频看到了Index-Hashtable之前，不得不说课讲得真的好，收获好多。 第二周：计划写project1，看完Index部分，仔细分析一下B Tree和B+ Tree。","link":"/2021/04/05/CMU15-445%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"CMU, database, lab","slug":"CMU-database-lab","link":"/tags/CMU-database-lab/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"database","slug":"database","link":"/categories/database/"}]}